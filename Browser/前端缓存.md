# 强缓存
浏览器中缓存分为两种，一种是需要发送`HTTP`请求，一种是不需要发送的。

首先检查强缓存，这个阶段不需要发送HTTP请求

如何检查呢？

在`HTTP/1.0`时期，使用的是**Expires**，而在`HTTP/1.1`使用的是**Cache-Control**。

## Expires
`Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。
```js
Expires: Wed, 22 Nov 2021 08:41:00 GMT
```
表示资源在`2021年11月22号8点41分`过期，过期了就得向服务端发请求。

但是这个方式有一个弊端，就是**服务器的时间和浏览器的时间可能并不一致**，那么服务器返回的这个过期时间可能就是不准确的。因此这种方式在`HTTP/1.1`中被抛弃了。

## Cache-Control
在`HTTP/1.1`中采用了这个字段，它与`Expires`不同是，它并没有采用**具体的过期时间点**这个方式，而是采用**过期时长**来控制缓存，对应的字段是`max-age`，比如
```js
Cache-Control:max-age=3600
```
代表这个响应返回后在3600秒，也就是一个小时之内可以直接使用缓存。

`max-age`有很多属性值。
- public：客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的`代理服务器`最后才能到达目标服务器，不仅仅是浏览器可以缓存数据，中间的任何代理点都可以缓存。
- private：只有浏览器能够缓存，中间代理服务器不能缓存。
- no-cache：跳过当前的强缓存，发送HTTP请求，直接进入协商缓存阶段。
- no-store：不进行任何形式的缓存。
- s-max-age：它和`max-age`的区别在于`s-max-age`是针对代理服务器的缓存时长。
- must-revalidate：加上这个字段一旦缓存过期，就必须回到源服务器验证。

然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——协商缓存了。

# 协商缓存
强缓存失效后，浏览器在请求头中携带响应的`缓存Tag`来向服务器发起请求，由服务器根据这个`缓存Tag`来决定是否使用缓存，这就是**协商缓存**。

具体来说，这样的缓存Tag分为两种：**Last-Modified**和**ETag**。

## Last-Modified
即`最后修改时间`。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，如果再次请求，会在请求头中携带**If-Modified-Since**字段，这个字段的值就是服务器传来的的最后修改时间。

服务器拿到请求头中的`If-Modified-Since`的字段后，会和服务器中`资源的最后修改时间`对比
- 如果请求头中的这个值小于最后的修改时间，说明该更新了。返回新的资源，和常规的HTTP请求响应一样。
- 否则返回**304**，告诉浏览器直接用缓存。

## ETag
`ETag`是服务器根据当前文件的内容，生成的唯一标识，只要里面的内容有改变，这个值就会改变。服务器通过响应头把这个值给浏览器。

浏览器收到`ETag`，当再次请求时，会在请求头中携带**If-None-Match**字段，其值为`ETag`的值，发送给服务器。

服务器收到`If-None-Match`后，会和服务器上资源的`ETag`对比
- 如果两者不同，说明要更新了。返回新的资源，和常规的HTTP请求响应一样。
- 否则返回**304**，告诉浏览器直接使用缓存

如果两种方式都支持的话，服务器会优先考虑`ETag`。

![强缓存和协商缓存](../asset/http强缓存与协商缓存.png)

# 缓存位置
前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache
### Service Worker
`Service Worker` 借鉴了 `Web Worker`的思路，即让 `JS` 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 `Service Worker Cache`。

`Service Worker` 同时也是 PWA 的重要实现机制。


### Memory Cache 和 Disk Cache
`Memory Cache`指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

`Disk Cache`就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：

- 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
- 内存使用率比较高的时候，文件优先进入磁盘

### Push Cache
即`推送缓存`，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。
