# 垃圾回收

js不像C语言一样手动清理内存，而是采用垃圾回收算法进行内存管理。

js中所有的引用数据类型保存在堆内存中，然后在栈内存中保存一个堆内存中实际对象的引用，当没有了引用关系后，越来越多的无引用对象就会占据内存，这时候就需要将其清理（回收）。

目前常见的垃圾回收算法：

1. **标记清除算法**：分为标记和清除两个阶段，标记阶段给所有对象做上标记，清除阶段把没有标记的对象销毁。缺点是会造成内存碎片。
2. **引用计数算法**：当一个对象被一个变量所引用时，给其计数为1，当这个对象又被另一个对象引用时，给其计数为2，如果变量的值被其他值所覆盖，其计数减1，当这个对象的引用计数为0时，也就是没有变量引用，垃圾回收器就会清理掉引用计数为0的对象。缺点是无法解决循环引用引起无法回收。

## V8的垃圾回收
V8对GC（垃圾回收）做了优化，将堆内存分为新生代和老生代，新生代的对象存活时间短，容量小，老生代的对象存活时间长，容量大。

**新生代垃圾回收**：采用`Scavenge`算法，将新生代内存一分为二，使用区和空闲区。新加入的对象放入使用区，当使用区满时，就进行垃圾回收，对使用区的活动对象做标记，之后将对象复制到空闲区并排序，将非活动对象清理掉，然后两个区的角色互换。

**老生代垃圾回收**：老生代的对象存活时间长，占用内存大，所以就采用标记清除算法，对于内存碎片问题，则是在标记阶段结束后，将不需要清理的对象向内存的一侧移动，最后处理掉需要清理的对象。

进行垃圾回收时会阻塞js脚本运行，等待垃圾回收完毕再运行js脚本，把这种行为叫做`全停顿`。

**增量标记**：为了减少全停顿的时间，将GC分为很多小的任务，与主线程交替执行。